## **Learning Objectives – Node.js (Session 3)**

By the end of this session, students will be able to:

---

## **1. Reinforce Understanding of Built-in Node.js Modules**

- Recall the purpose of built-in (internal) modules in Node.js
- Explore remaining commonly used APIs of the `fs` module
- Understand synchronous vs asynchronous file system operations
- Identify use cases where file system access is required in backend applications

---

## **2. Understand the Need for External Modules**

- Recognize limitations of writing everything from scratch
- Explain how backend development benefits from reusable libraries
- Distinguish between:

  - Built-in (internal) modules
  - External (third-party) modules

- Understand the role of the Node.js ecosystem in rapid backend development

---

## **3. Define What a Package Manager Is**

- Define a **package manager** as a tool that:

  - Installs external libraries
  - Manages dependencies
  - Tracks versions

- Understand why package management is critical for:

  - Consistency across environments
  - Collaboration in teams
  - Application stability

---

## **4. Understand Node Package Manager (NPM)**

- Identify **NPM** as the default package manager for Node.js
- Understand NPM’s responsibilities:

  - Installing packages
  - Maintaining dependency trees
  - Managing project metadata

- Differentiate between:

  - Local dependencies
  - Global dependencies (conceptual overview)

---

## **5. Initialize a Node.js Project**

- Understand the purpose of `npm init`
- Use `npm init -y` to initialize a project
- Explain the role of `package.json` in a Node.js project

---

## **6. Understand Project Structure Created by NPM**

- Identify and explain the purpose of:

  - `package.json`
  - `node_modules`
  - `package-lock.json`

- Understand:

  - Why `node_modules` should not be committed to version control
  - Why `package-lock.json` must be committed

- Explain how dependencies are resolved during installation

---

## **7. Understand Versioning and Dependency Management**

- Understand semantic versioning (major, minor, patch)
- Explain the meaning of version prefixes:

  - `^`
  - `~`

- Understand how dependency versions impact application stability
- Recognize risks of uncontrolled dependency upgrades

---

## **8. Use External Modules in a Node.js Project**

- Install and import simple external packages
- Use example utility packages such as:

  - `is-even`
  - `chalk`

- Understand how external modules integrate into Node.js code
- Identify how ESM syntax is used with external dependencies

---

## **9. Understand Scripts and NPM Commands**

- Identify commonly used NPM commands:

  - `npm install`
  - `npm uninstall`
  - `npm run`

- Understand the purpose of `scripts` in `package.json`
- Execute custom scripts using NPM

---

## **10. Prepare for Express and Backend Frameworks**

- Understand how:

  - Node.js provides the runtime
  - NPM provides the ecosystem

- Recognize Express as an external module built on Node.js
- Build readiness to:

  - Install Express
  - Structure backend projects
  - Manage dependencies in real applications

---

## **End-of-Session Outcome**

By the end of Node.js Day 3, students will:

- Confidently manage Node.js projects using NPM
- Understand project structure and dependency management
- Use external modules effectively
- Be fully prepared to start **Express.js** development

---

## **Node Module Completion Outcome**

After completing **Node Day 1–3**, students will:

- Understand **why backend exists**
- Know **how Node.js works internally**
- Be capable of **setting up and managing backend projects**
- Be ready to build **real APIs using Express**

---
